// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: msp/azure/openai/chat/v1/completions.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Msp_Azure_Openai_Chat_V1_ChatCompletionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var temperature: Float = 0

  public var topP: Float = 0

  public var stream: Bool = false

  public var stops: [String] = []

  public var maxTokens: UInt32 = 0

  public var presencePenalty: Float = 0

  public var frequencyPenalty: Float = 0

  public var logitBias: Dictionary<String,Float> = [:]

  public var user: String = String()

  public var messages: [Msp_Azure_Openai_Chat_V1_ChatCompletionRequestMessage] = []

  ///  repeated DataSource data_sources = 11;
  public var n: UInt32 = 0

  ///  ResponseFormat response_format = 14;
  ///  repeated Tool tools = 15;
  ///  ToolChoice tool_choice = 16;
  ///  repeated Function functions = 17;
  ///  FunctionCall function_call = 18;
  public var seed: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Msp_Azure_Openai_Chat_V1_ChatCompletionRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: String = String()

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Msp_Azure_Openai_Chat_V1_ChatCompletionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var object: String = String()

  public var created: UInt64 = 0

  public var model: String = String()

  public var usage: Msp_Azure_Openai_Chat_V1_Usage {
    get {return _usage ?? Msp_Azure_Openai_Chat_V1_Usage()}
    set {_usage = newValue}
  }
  /// Returns true if `usage` has been explicitly set.
  public var hasUsage: Bool {return self._usage != nil}
  /// Clears the value of `usage`. Subsequent reads from it will return its default value.
  public mutating func clearUsage() {self._usage = nil}

  public var systemFingerprint: String = String()

  public var promptFilterResults: [Msp_Azure_Openai_V1_PromptFilterResult] = []

  public var choices: [Msp_Azure_Openai_Chat_V1_Choice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Msp_Azure_Openai_Chat_V1_Usage? = nil
}

public struct Msp_Azure_Openai_Chat_V1_Usage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var promptTokens: UInt64 = 0

  public var completionTokens: UInt64 = 0

  public var totalTokens: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Msp_Azure_Openai_Chat_V1_Choice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt32 = 0

  public var finishReason: String = String()

  public var message: Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage {
    get {return _message ?? Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var contentFilterResult: Msp_Azure_Openai_V1_ContentFilterChoiceResult {
    get {return _contentFilterResult ?? Msp_Azure_Openai_V1_ContentFilterChoiceResult()}
    set {_contentFilterResult = newValue}
  }
  /// Returns true if `contentFilterResult` has been explicitly set.
  public var hasContentFilterResult: Bool {return self._contentFilterResult != nil}
  /// Clears the value of `contentFilterResult`. Subsequent reads from it will return its default value.
  public mutating func clearContentFilterResult() {self._contentFilterResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage? = nil
  fileprivate var _contentFilterResult: Msp_Azure_Openai_V1_ContentFilterChoiceResult? = nil
}

public struct Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: String = String()

  public var content: String = String()

  public var toolCalls: [Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall] = []

  public var functionCall: Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall {
    get {return _functionCall ?? Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall()}
    set {_functionCall = newValue}
  }
  /// Returns true if `functionCall` has been explicitly set.
  public var hasFunctionCall: Bool {return self._functionCall != nil}
  /// Clears the value of `functionCall`. Subsequent reads from it will return its default value.
  public mutating func clearFunctionCall() {self._functionCall = nil}

  public var context: Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext {
    get {return _context ?? Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _functionCall: Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall? = nil
  fileprivate var _context: Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext? = nil
}

public struct Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: String = String()

  public var function: Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.Function {
    get {return _function ?? Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.Function()}
    set {_function = newValue}
  }
  /// Returns true if `function` has been explicitly set.
  public var hasFunction: Bool {return self._function != nil}
  /// Clears the value of `function`. Subsequent reads from it will return its default value.
  public mutating func clearFunction() {self._function = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Function {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var argument: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _function: Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.Function? = nil
}

public struct Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var argument: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var citations: [Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext.Citation] = []

  public var intent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Citation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var content: String = String()

    public var title: String = String()

    public var url: String = String()

    public var filepath: String = String()

    public var chunkID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Msp_Azure_Openai_Chat_V1_ErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var param: String {
    get {return _storage._param}
    set {_uniqueStorage()._param = newValue}
  }

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var innerError: Msp_Azure_Openai_Chat_V1_ErrorResponse.InnerError {
    get {return _storage._innerError ?? Msp_Azure_Openai_Chat_V1_ErrorResponse.InnerError()}
    set {_uniqueStorage()._innerError = newValue}
  }
  /// Returns true if `innerError` has been explicitly set.
  public var hasInnerError: Bool {return _storage._innerError != nil}
  /// Clears the value of `innerError`. Subsequent reads from it will return its default value.
  public mutating func clearInnerError() {_uniqueStorage()._innerError = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct InnerError {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: String = String()

    public var contentFilterResult: Msp_Azure_Openai_V1_ContentFilterPromptResult {
      get {return _contentFilterResult ?? Msp_Azure_Openai_V1_ContentFilterPromptResult()}
      set {_contentFilterResult = newValue}
    }
    /// Returns true if `contentFilterResult` has been explicitly set.
    public var hasContentFilterResult: Bool {return self._contentFilterResult != nil}
    /// Clears the value of `contentFilterResult`. Subsequent reads from it will return its default value.
    public mutating func clearContentFilterResult() {self._contentFilterResult = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _contentFilterResult: Msp_Azure_Openai_V1_ContentFilterPromptResult? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Msp_Azure_Openai_Chat_V1_ChatCompletionRequest: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ChatCompletionRequestMessage: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ChatCompletionResponse: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_Usage: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_Choice: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.Function: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext.Citation: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ErrorResponse: @unchecked Sendable {}
extension Msp_Azure_Openai_Chat_V1_ErrorResponse.InnerError: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "msp.azure.openai.chat.v1"

extension Msp_Azure_Openai_Chat_V1_ChatCompletionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatCompletionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "temperature"),
    2: .standard(proto: "top_p"),
    3: .same(proto: "stream"),
    4: .unique(proto: "stops", json: "stop"),
    5: .standard(proto: "max_tokens"),
    6: .standard(proto: "presence_penalty"),
    7: .standard(proto: "frequency_penalty"),
    8: .standard(proto: "logit_bias"),
    9: .same(proto: "user"),
    10: .same(proto: "messages"),
    12: .same(proto: "n"),
    13: .same(proto: "seed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.temperature) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.topP) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.stream) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.stops) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.maxTokens) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.presencePenalty) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.frequencyPenalty) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: &self.logitBias) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.n) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.seed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.temperature != 0 {
      try visitor.visitSingularFloatField(value: self.temperature, fieldNumber: 1)
    }
    if self.topP != 0 {
      try visitor.visitSingularFloatField(value: self.topP, fieldNumber: 2)
    }
    if self.stream != false {
      try visitor.visitSingularBoolField(value: self.stream, fieldNumber: 3)
    }
    if !self.stops.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stops, fieldNumber: 4)
    }
    if self.maxTokens != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxTokens, fieldNumber: 5)
    }
    if self.presencePenalty != 0 {
      try visitor.visitSingularFloatField(value: self.presencePenalty, fieldNumber: 6)
    }
    if self.frequencyPenalty != 0 {
      try visitor.visitSingularFloatField(value: self.frequencyPenalty, fieldNumber: 7)
    }
    if !self.logitBias.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: self.logitBias, fieldNumber: 8)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 9)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 10)
    }
    if self.n != 0 {
      try visitor.visitSingularUInt32Field(value: self.n, fieldNumber: 12)
    }
    if self.seed != 0 {
      try visitor.visitSingularInt64Field(value: self.seed, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ChatCompletionRequest, rhs: Msp_Azure_Openai_Chat_V1_ChatCompletionRequest) -> Bool {
    if lhs.temperature != rhs.temperature {return false}
    if lhs.topP != rhs.topP {return false}
    if lhs.stream != rhs.stream {return false}
    if lhs.stops != rhs.stops {return false}
    if lhs.maxTokens != rhs.maxTokens {return false}
    if lhs.presencePenalty != rhs.presencePenalty {return false}
    if lhs.frequencyPenalty != rhs.frequencyPenalty {return false}
    if lhs.logitBias != rhs.logitBias {return false}
    if lhs.user != rhs.user {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.n != rhs.n {return false}
    if lhs.seed != rhs.seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ChatCompletionRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatCompletionRequestMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ChatCompletionRequestMessage, rhs: Msp_Azure_Openai_Chat_V1_ChatCompletionRequestMessage) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ChatCompletionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatCompletionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "object"),
    3: .same(proto: "created"),
    4: .same(proto: "model"),
    5: .same(proto: "usage"),
    6: .standard(proto: "system_fingerprint"),
    7: .standard(proto: "prompt_filter_results"),
    8: .same(proto: "choices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.object) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.created) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.systemFingerprint) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.promptFilterResults) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.choices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.object.isEmpty {
      try visitor.visitSingularStringField(value: self.object, fieldNumber: 2)
    }
    if self.created != 0 {
      try visitor.visitSingularUInt64Field(value: self.created, fieldNumber: 3)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 4)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.systemFingerprint.isEmpty {
      try visitor.visitSingularStringField(value: self.systemFingerprint, fieldNumber: 6)
    }
    if !self.promptFilterResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.promptFilterResults, fieldNumber: 7)
    }
    if !self.choices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.choices, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ChatCompletionResponse, rhs: Msp_Azure_Openai_Chat_V1_ChatCompletionResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.object != rhs.object {return false}
    if lhs.created != rhs.created {return false}
    if lhs.model != rhs.model {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.systemFingerprint != rhs.systemFingerprint {return false}
    if lhs.promptFilterResults != rhs.promptFilterResults {return false}
    if lhs.choices != rhs.choices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_Usage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Usage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prompt_tokens"),
    2: .standard(proto: "completion_tokens"),
    3: .standard(proto: "total_tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.promptTokens) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.completionTokens) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.totalTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.promptTokens != 0 {
      try visitor.visitSingularUInt64Field(value: self.promptTokens, fieldNumber: 1)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularUInt64Field(value: self.completionTokens, fieldNumber: 2)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalTokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_Usage, rhs: Msp_Azure_Openai_Chat_V1_Usage) -> Bool {
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_Choice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Choice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "finish_reason"),
    3: .same(proto: "message"),
    4: .unique(proto: "content_filter_result", json: "content_filter_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.finishReason) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._contentFilterResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.finishReason.isEmpty {
      try visitor.visitSingularStringField(value: self.finishReason, fieldNumber: 2)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._contentFilterResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_Choice, rhs: Msp_Azure_Openai_Chat_V1_Choice) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.finishReason != rhs.finishReason {return false}
    if lhs._message != rhs._message {return false}
    if lhs._contentFilterResult != rhs._contentFilterResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatCompletionResponseMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "content"),
    3: .standard(proto: "tool_calls"),
    4: .standard(proto: "function_call"),
    5: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.toolCalls) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._functionCall) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    if !self.toolCalls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toolCalls, fieldNumber: 3)
    }
    try { if let v = self._functionCall {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage, rhs: Msp_Azure_Openai_Chat_V1_ChatCompletionResponseMessage) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.content != rhs.content {return false}
    if lhs.toolCalls != rhs.toolCalls {return false}
    if lhs._functionCall != rhs._functionCall {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatCompletionMessageToolCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "function"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._function) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._function {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall, rhs: Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs._function != rhs._function {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.Function: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.protoMessageName + ".Function"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .unique(proto: "argument", json: "arguments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.argument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.argument.isEmpty {
      try visitor.visitSingularStringField(value: self.argument, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.Function, rhs: Msp_Azure_Openai_Chat_V1_ChatCompletionMessageToolCall.Function) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.argument != rhs.argument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatCompletionFunctionCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .unique(proto: "argument", json: "arguments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.argument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.argument.isEmpty {
      try visitor.visitSingularStringField(value: self.argument, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall, rhs: Msp_Azure_Openai_Chat_V1_ChatCompletionFunctionCall) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.argument != rhs.argument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AzureChatExtensionsMessageContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "citations"),
    2: .same(proto: "intent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.citations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.intent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.citations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.citations, fieldNumber: 1)
    }
    if !self.intent.isEmpty {
      try visitor.visitSingularStringField(value: self.intent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext, rhs: Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext) -> Bool {
    if lhs.citations != rhs.citations {return false}
    if lhs.intent != rhs.intent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext.Citation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext.protoMessageName + ".Citation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "title"),
    3: .same(proto: "url"),
    4: .same(proto: "filepath"),
    5: .standard(proto: "chunk_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filepath) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.chunkID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if !self.filepath.isEmpty {
      try visitor.visitSingularStringField(value: self.filepath, fieldNumber: 4)
    }
    if !self.chunkID.isEmpty {
      try visitor.visitSingularStringField(value: self.chunkID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext.Citation, rhs: Msp_Azure_Openai_Chat_V1_AzureChatExtensionsMessageContext.Citation) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.title != rhs.title {return false}
    if lhs.url != rhs.url {return false}
    if lhs.filepath != rhs.filepath {return false}
    if lhs.chunkID != rhs.chunkID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "param"),
    4: .same(proto: "type"),
    5: .standard(proto: "inner_error"),
  ]

  fileprivate class _StorageClass {
    var _code: String = String()
    var _message: String = String()
    var _param: String = String()
    var _type: String = String()
    var _innerError: Msp_Azure_Openai_Chat_V1_ErrorResponse.InnerError? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _param = source._param
      _type = source._type
      _innerError = source._innerError
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._param) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._innerError) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._code.isEmpty {
        try visitor.visitSingularStringField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      if !_storage._param.isEmpty {
        try visitor.visitSingularStringField(value: _storage._param, fieldNumber: 3)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 4)
      }
      try { if let v = _storage._innerError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ErrorResponse, rhs: Msp_Azure_Openai_Chat_V1_ErrorResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._param != rhs_storage._param {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._innerError != rhs_storage._innerError {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Msp_Azure_Openai_Chat_V1_ErrorResponse.InnerError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Msp_Azure_Openai_Chat_V1_ErrorResponse.protoMessageName + ".InnerError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .unique(proto: "content_filter_result", json: "content_filter_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contentFilterResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._contentFilterResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Msp_Azure_Openai_Chat_V1_ErrorResponse.InnerError, rhs: Msp_Azure_Openai_Chat_V1_ErrorResponse.InnerError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._contentFilterResult != rhs._contentFilterResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
